Ресурсы это специальные Сигналы, которые были созданы для того, чтобы помочь с асинхронной загрузкой. Они оборачивают асинхронные вызовы таким образом, чтобы мы могли на полную мощность использовать модель распределенного выполнения Solid.
Эта модель противоположна `async`/`await` или генераторам, которые используют последовательную модель выполнения. В результате использования ресурсов мы избегаем блокировки выполнения.

Для использования ресурсов необходимо создать функцию-сборщик (`fetcher function`), которая будет возвращать промис. Например, вы можете использовать её для того, чтобы делать запрос на REST или GraphQL API. Ресурсы не имеют строгих указаний о том, как вы загружаете ваши данные и о том, как эта функция выглядит внутри, до тех пор пока результатом выполнения этой функции является промис.

В результате выполнения Ресурса вы получаете реактивные свойства `loading` и `error`, которые помогут вам легко видеть статус текущего запроса.

Давайте заменим наш сигнал `user` ресурсом:
```js
const [user] = createResource(userId, fetchUser);
```
В данном примере он зависит от сигнала `userId` и при его изменении метод будет вызван снова.

Второе значение в результате выполнения `createResource` включает в себя метод `mutate`, который позволяет обновить внутренний сигнал `userId`, и метод `refetch`, который позволяет заново выполнить запрос, даже если сигнал `userId` не изменился.

```js
const [user, { mutate, refetch }] = createResource(userId, fetchUser);
```

`lazy` внутри себя использует `createResource` для того, чтобы управлять динамическими импортами.