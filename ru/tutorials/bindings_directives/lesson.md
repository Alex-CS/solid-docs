Solid поддерживает кастомные директивы (`custom directives`) через суффикс `use:`. Это упрощенная форма использования `ref`, но запись через `use:` позволяет нам использовать несколько байндингов на одном элементе без конфликтов и внешне напоминает паттерны директив из других популярных библиотек. Директива `use:` отлично подходит для создания переиспользуемых паттернов поведения для элементов DOM.

Кастомные директивы это простые функции, которые принимают два аргумента: `element` и `valueAccessor`. `Element` это DOM элемент на который мы хотим повесить `use:`, а `valueAccessor` это функция-геттер (`getter function`) для значения, которые мы передаем в аттрибут. До тех пор пока функция-директив имеет импорт в файле мы можем использовать с ней `use:`. 

> Важно! Функция `use:` определяется компилятором для трансформации, поэтому импорт функции должен быть в скоупе (`scope`) и не может быть частью расширений (`spreads`) или использоваться на компонентах.

В нашем примере мы создадим простую директиву с логикой для клика за пределы компонента. Это распространенный вариант поведения для модальных или всплывающих окон (`popups`). Для начала мы должны импортировать и применить нашу директиву к элементу:

```jsx
import clickOutside from './click-outside.tsx'

<div class="modal" use:clickOutside={() => setShow(false)}>
  Some Modal
</div>
```

Открываем файл `click-outside.tsx`, где мы будем писать нашу пользовательскую директиву. Эта директива будет определять поведение на клике в body и на очищении компонента:

```jsx
export default function clickOutside(el, accessor) {
  const onClick = (e) => !el.contains(e.target) && accessor()?.();
  document.body.addEventListener("click", onClick);

  onCleanup(() => document.body.removeEventListener("click", onClick));
}
```

Теперь логика для нашего модального окна завершена, а мы, при необходимости сможем легко переиспользовать логику для других элементов!
